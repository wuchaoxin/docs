import{_ as e,c as d,o,a as c}from"./app.b713d63a.js";const _=JSON.parse('{"title":"JSBridge","description":"","frontmatter":{},"headers":[{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[{"level":3,"title":"初始化","slug":"初始化","link":"#初始化","children":[]},{"level":3,"title":"JS 调用 Native","slug":"js-调用-native","link":"#js-调用-native","children":[]},{"level":3,"title":"Native 调用 JS","slug":"native-调用-js","link":"#native-调用-js","children":[]}]},{"level":2,"title":"实际操作","slug":"实际操作","link":"#实际操作","children":[{"level":3,"title":"Bridge","slug":"bridge","link":"#bridge","children":[]},{"level":3,"title":"autoBridge","slug":"autobridge","link":"#autobridge","children":[]}]}],"relativePath":"frontend-js-bridge-guide/README.md","lastUpdated":1675835613000}'),i={name:"frontend-js-bridge-guide/README.md"},t=c('<h1 id="jsbridge" tabindex="-1">JSBridge <a class="header-anchor" href="#jsbridge" aria-hidden="true">#</a></h1><p>JSBridge 是一种 JS 实现的 Bridge，连接着桥两端的 Native 和 H5。它在 APP 内方便地让 Native 调用 JS，JS 调用 Native ，是双向通信的通道。JSBridge 主要提供了 JS 调用 Native 代码的能力，实现原生功能如查看本地相册、打开摄像头、指纹支付等。</p><table><thead><tr><th>name</th><th>H5</th><th>Native</th></tr></thead><tbody><tr><td>稳定性</td><td>调用系统浏览器内核，稳定性较差</td><td>使用原生内核，更加稳定</td></tr><tr><td>灵活性</td><td>版本迭代快，上线灵活</td><td>迭代慢，需要应用商店审核，上线速度受限制</td></tr><tr><td>流畅度</td><td>有时加载慢，给用户“卡顿”的感觉</td><td>加载速度快，更加流畅</td></tr><tr><td>用户体验</td><td>功能受浏览器限制，体验有时较差</td><td>原生系统 api 丰富，能实现的功能较多，体验较好</td></tr><tr><td>可移植性</td><td>兼容跨平台跨系统，如 PC 与 移动端，iOS 与 Android</td><td>可移植性较低，对于 iOS 和 Android 需要维护两套代码</td></tr></tbody></table><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-hidden="true">#</a></h2><p>目前采用通信的方式是 <code>拦截 URL Scheme</code>。H5 方进行创建一个隐藏的 <code>iframe</code>，该 <code>iframe</code> 设置上协商好的 <code>URL Scheme</code>, Android 和 iOS 都可以通过拦截该 <code>URL Scheme</code> 并解析 scheme 来决定是否进行对应的 Native 代码逻辑处理。</p><blockquote><p>注：原理相关主要 <code>JS</code> 为主，H5 并不十分了解 <code>APP</code> 方的逻辑。</p></blockquote><blockquote><p>原理解释主要是面向 <code>IOS</code> 方，<code>Android</code> 方于其类似，逻辑稍有不同但是不做过多解释。</p></blockquote><h3 id="初始化" tabindex="-1">初始化 <a class="header-anchor" href="#初始化" aria-hidden="true">#</a></h3><p>创建一个 src 为 <code>https://__bridge_loaded__</code> 的 <code>iframe</code>，用于告诉 <code>App</code> 需要进行初始化了。</p><blockquote><p>其最开始本身的作用是为了让 <code>App</code> 执行 <code>injectJavascriptFile</code> 方法，但是 bridge 相关的逻辑都是 <code>JS</code>这边注入的，但是也不能缺少这一步，不清楚 <code>App</code> 那边的逻辑</p></blockquote><h3 id="js-调用-native" tabindex="-1">JS 调用 Native <a class="header-anchor" href="#js-调用-native" aria-hidden="true">#</a></h3><ol><li>H5 方调用 <code>callHandler</code> 方法，执行 <code>_doSend</code> 方法。</li><li><code>_doSend</code> 方法会创建一个 src 为 <code>__wvjb_queue_message__</code> 的 <code>iframe</code>，同时我们会向 <code>sendMessageQueue</code> 里面加入本次发送的信息。</li><li><code>App</code> 拦截到这个请求，会进行解析。</li><li>解析完毕后，会来调用 H5 的 <code>_fetchQueue</code> 方法以来获取 <code>sendMessageQueue</code>属性。</li><li>如果有回调函数那么 <code>App</code> 会调用 <code>H5</code>这边的 <code>_dispatchMessageFromObjC</code> （此时 <code>App</code> 返回的 <code>message</code> 会携带 <code>responseId</code>）来进行回调函数的执行。</li></ol><h3 id="native-调用-js" tabindex="-1">Native 调用 JS <a class="header-anchor" href="#native-调用-js" aria-hidden="true">#</a></h3><blockquote><p>Native 调用 JS 比较简单，只要 H5 将 JS 方法暴露在 Window 上给 Native 调用即可。</p></blockquote><ol><li><code>App</code> 主动调用 <code>H5</code>方的 <code>_handleMessageFromObjC</code> 方法。</li><li><code>H5</code> 继续执行 <code>_doDispatchMessageFromObjC</code> 方法利用 <code>App</code> 所携带的 <code>callbackId</code>（没有那么就不执行）进行调用 <code>_doSend</code> 方法。</li><li>... 后续步骤同上的 <code>_doSend</code> 方法。</li><li>执行后，还会检测 <code>messageHandlers</code> 中是否有需要监听的事件，如果有并且符合事件名会进行一次执行。</li></ol><h2 id="实际操作" tabindex="-1">实际操作 <a class="header-anchor" href="#实际操作" aria-hidden="true">#</a></h2><h3 id="bridge" tabindex="-1">Bridge <a class="header-anchor" href="#bridge" aria-hidden="true">#</a></h3><ul><li><code>H5</code> 方当调用后 <code>initBridge</code> 方法后，会在 <code>window</code> 全局对象对象上挂载 <code>WebViewJavascriptBridge</code> 对象。</li><li>当 <code>H5</code> 方调用 <code>window.WebViewJavascriptBridge.callHandler</code> 方法后，调用 <code>Native</code> 方事件。</li><li>当 <code>H5</code> 方调用 <code>window.WebViewJavascriptBridge.registerHandler</code> 方法后，会进行监听 <code>Native</code> 方事件。</li></ul><h3 id="autobridge" tabindex="-1">autoBridge <a class="header-anchor" href="#autobridge" aria-hidden="true">#</a></h3><p><code>autoBridge</code> 和 <code>bridge</code> 使用方法一模一样，不过利用了 <code>Proxy</code> 进行了一次拦截，完成以下操作：</p><ul><li>会自动进行初始化 <code>Bridge</code> （并不需要手动执行 <code>initBridge</code>）</li><li>会自动判断当前是否在 <code>App</code> 环境内，如果不在将不会执行</li><li>将禁止修改 <code>autoBridge</code> 对象</li></ul>',21),a=[t];function r(l,n,s,h,p,g){return o(),d("div",null,a)}const b=e(i,[["render",r]]);export{_ as __pageData,b as default};
